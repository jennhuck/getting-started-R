---
title: "Getting Started with R"
author: "Jennifer Huck, Data Librarian, UVA Library"
date: "Fall 2022"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
  markdown:
    wrap: 72
---

# Intro to R

This R Script will introduce you to scripts, installing and loading
packages, using tidyverse, keeping R up to date, viewing and changing
your working directory, and importing data and evaluating data. We will use data
about Albemarle County homes.

# Goals for our Workshop

These are the goals for today's workshop:

-   Understand the features of R
-   Know where to look for help and to learn more about R
-   Orient yourself to R and RStudio
-   Understand the basics of working with data: load, explore, and save
    data
-   Learn some best practices for using R scripts, using data, and
    projects
-   Understand the basics of objects, functions, and indexing

The intended audience is beginner-level, with no previous experience
using R.

# Orientation to R and RStudio

R is the underlying statistical computing environment. You can think of
this like the engine of a car. That makes RStudio like the dashboard.
Basically, RStudio makes it easier to use R because it is easier to run
and execute code. After you install R and RStudio, you only need to run
RStudio.

## A quick tour of RStudio Panes

RStudio shows four panes by default. The two most important are the
Console (bottom left) and the Script Editor (top left). The panes on the
right have multiple parts.

## The Console

The Console is where you can enter commands that R will execute, but R
will not save this code in an organized way. You might want to use the
console to enter commands that you want to test out or commands that you
know you do not want to save.

Try typing this into the console, and press return:

20^2

# Scripts and R Markdown 

Use scripts to save your work for future analysis. Scripts are an
essential part of reproducibility, either for collaborators, or your
future self. You should rely on them rather than clicking through a
graphical user interface.  Reproducibility practices might have a little bit of up-front cost, but I promise it makes your life easier in the long run.

R Scripts are very simple documents. It's a plain text document that
stores your code. 

Let's open one now: Go to File...new File...R Script. In the file, enter:

20^2
20*4

Press *CTRL+Enter* to run a line at a time, or highlight what you want
to run and press the same keys.  

## Comments

You should use lots of comments when you write your own scripts! Do
yourself a favor, and leave comments for the future version of yourself.

Preface comments with a hashtag: `#`

Go back to your very simple R script, and include two comments (comment, another
comment), one each before the two lines of code.

You can also use hashtags to "comment out" parts of your script when you are testing your code.

Also notice the gutter (bottom of script pane): you can use four dashes after a comment (-) to organize the script. 

Now save the document and the next time you need to review your tables or graphs, you will know exactly how you made them.

# Basic R operations

Let's get some output from R starting with some simple math.

Here, the plus sign is the 'operator'. Operators are symbols that
represent some sort of action.

Remember, click the *Run* button within the chunk or place your cursor
inside it and pressing *Ctrl+Shift+Enter* (Win/Linux) or
*Cmd+Shift+Return* (Mac).

```{r}
2+8/2
```

Let's try that again, but slightly different:

```{r}
(2+8)/2 
```

You can also highlight only some code, and press *Ctrl+Enter*
(Win/Linux) or *Cmd+Return* (Mac) to run the highlighted section.

You can also highlight some code to only run certain sections of the
command or script, then press *Ctrl+Enter* (Win/Linux) or *Cmd+Return*
(Mac) to run.

Notice that the Console shows a \> (right-pointing carrot) when it is
ready to accept commands. This time, try highlighting and running only
`(2+8` above, intentionally leaving out `)/2`. You will see a `+` (plus
sign) in the console. The `+` tells you R is waiting for more input. You
can click into the console and press ESC, or you can highlight and run
the rest of the line.

## Creating objects

It is more useful and interesting to assign values to objects. We create
an object by using this form: *object \<- value*. Say in your head
"object gets value". We are using the assignment operator: `<-` Use `<-`
instead of `=`.

Tip: Keyboard shortcut: For assignment operator `<-` use *ALT+-* (for
Windows) or *OPTION+-* (for Mac). That is, hold the ALT/OPTION key, then
press the - key (minus sign key).

Let's make some objects for housing square feet.

```{r}
cottage <- 1000   # Say "cottage gets one thousand"; verify in environment
(mansion <- 10000)  # putting parenthesis around the call prints the value of `mansion`
```

## Mini Code Along

Take advantage of RStudio autocomplete facility: type the first 3
letters of cottage, press Tab or Enter, then run.

## More objects

I will put parentheses around the code to print to the console/chunk
output. I am only doing this because it is a workshop situation and I want to display the output. You don't have to do it like this every time.

Use *Ctrl+Enter* (Win/Linux) or *Cmd+Return* (Mac) to run specific lines
for this next chunk:

```{r}
Cottage <- 4000 # R is case sensitive, so be careful with your upper/lowercase

(condo <- 3000) # Put parenthesis around the call to print to the console

condo <- 2000   # We can re-assign objects
condo           # Verify by looking in the Environment or printing to console by
                # typing the name of the object

cottage / 2       # We can do arithmetic with R objects
cottage + mansion # Simply prints to console, we aren't saving this as an object 
                  # in the Environment

two_homes <- cottage + mansion  # Save our arithmetic as a new object

rm(Cottage)       # Remove an object

# Now type Cottage into the console.
# We get an error, because the object no longer exists
```


## Your turn \#1

Do these exercises in order!

```{r}
#1. A cottage costs $100.  Create an object labeled `cottage_cost` that gets the value `100`.  (Do not include the dollar sign.)

#2. How much does the cottage cost in Euros?  Use `cottage_cost`, multiply by `0.8`, and save the object as `cottage_euros`.

#3. Whoops - the cottage is actually $200 - twice what we thought.  Update `cottage_cost` to `200`. Update `cottage_cost` in Question 1 to 200, and run. (Don't run anything else.)

#4.  What do you think the current content of the object cottage_euros is? Is it 80 or 160?
```

## Functions

Functions are like verbs. Objects are like nouns. Functions allow you to
do things with your objects.

Functions get one or more inputs called arguments. Functions often
return a value.

Let's try a very simple function: `sqrt()`

```{r}
sqrt(100)
```

The value 100 is given to the sqrt() function, the sqrt() function
calculates the square root, and returns the value.

The sqrt() function is very simple because it takes only one argument.

Let's try a function that can take multiple arguments: `round()`

```{r}
round(3.14159)
```

The default is to round to the nearest whole number. If we want to round
to more digits, we can get more info on the round() function, by using
`args(round)` or looking at the help page `?round`

Let's take a quick look at the Examples section for the round() help
page, and open those examples in a new script.

We see that if we want a different number of digits, we can type
digits=2, or however many we want.

```{r}
round(3.14159, digits = 2)
```

If you provide the arguments in the exact same order as they are defined
you do not have to name them:

```{r}
round(3.14159, 2)
```

It is good practice to put the non-optional arguments (like the
number you are rounding) first in your function call, and to specify the
names of all optional arguments. If you don't, someone reading your code
might have to look up the definition of a function with unfamiliar
arguments to understand what you are doing.

## Vectors and Data Types

A vector is the most common and basic data type in R, and is pretty much the workhorse of R. A vector is composed by a series of values, which can be either numbers or characters. We can assign a series of values to a vector using the `c()` function. For example we can create a vector of the age of homes and assign it to a new object `home_age`:

Numeric vector:

```{r}
age <- c(15, 62, 39, 4) 
age
```

A vector can also contain characters. For example, we can have a vector of the types of heating in a home (`heating`)

```{r}
heating <- c("furnace", "radiator", "heatpump")
heating
```
The quotes around “furnace”, etc. are essential here. Without the quotes R will assume there are objects called `furnace`, `radiator`, and `heatpump`. As these objects don’t exist in R’s memory, there will be an error message.

Character vector missing the quotes:

```{r}
heating <- c(furnace, radiator, heatpump) # These objects do not exist, so you get an error
```

There are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector:
```{r}
length(age)
```
```{r}
length(heating)
```

An important feature of a vector, is that all of the elements are the same type of data. The function class() indicates the class (the type of element) of an object:
```{r}
class(age)
```
```{r}
class(heating)
```

##Subsetting vectors 

Indexing vectors - use brackets to reference elements in a vector. 

R starts counting from 1.

```{r}
age[3]      # pulls 3rd element
heating[2:3]   # pulls 2nd-3rd elements
heating[c(1,3)]    # pulls non-sequential elements
```

##Conditional subsetting
Another common way of subsetting is by using a logical vector.

```{r}
age > 30
```
```{r}
age[age > 30]
```

## Your turn \#2

```{r}
#1.  Pull the second element from the numeric vector age (above).

#2.  Create a character vector of first names consisting of 4 components: Jenn, Clay, Jacob, and Nancy 

#3.  Pull the 2nd and 4th elements of the vector you created in step 2.
```

## Clear our workspace

Let's clear the objects we just made from our workspace since we don't
need them anymore. Try the remove function (below), or click the Broom
icon in the Environment console.

```{r}
rm(list = ls())
```

# Starting with Data

## What is a Working Directory? What is the best way to set one?

R always has a working directory set. The working directory is where **R
looks for your files**, that is, where it looks for your scripts and
data. R will look for other files and directories by starting at the
root of your working directory. The working directory can be any
directory (aka folder) -- it doesn't have to be the same folder where
you installed R.

## View Your Working Directory

R always has a working directory set. Get your working directory:

```{r}
getwd()
```

Note that you can also see the working directory listed at the top of
the Console.

You might want to change the working directory. For that you have to
"set" the working directory.

## An example using a hard coded working directory

Here is an example of setting your working directory using `setwd()`.

`setwd("C:/Users/jah2ax.ESERVICES/Box Sync/_R/workshops/intro_R")`

Note that this line of code will not work for you. It works for me,
right now, on this computer. If I ever move my files, that line will
stop working for me, too.

There is a better way: RStudio Projects.

## Create a RStudio Project

Create a project by selecting the R Project icon (upper right corner) or
File...New Project...Existing Directory...select the directory (folder)
where this R Notebook is saved.

RStudio Projects are great because they automatically set your working
directory to the top level of your project directory (folder). They also
give you a fresh "environment" which we will explain in a moment.

# Loading packages, reading conflicts

We need more verbs! R comes pre-loaded with several packages, but one of
the cool things about R is that people develop new functions all the
time. Those functions are distributed in packages. CRAN is the best
place to find packages because they are validated. You can also find
package on GitHub, but "buyer beware" - these might not work or might
not have been updated to keep pace with new versions of R.

Let's load a package.

Recall that you installed the tidyverse package before the workshop.
Remember, you only *install* a package once, but you must *load* it for
every \# new R session. Think of it like a lightbulb that you install
once, but switch on every time you need it.

Let's load our first package: tidyverse

```{r}
library(tidyverse) 
```

Note the message that we see in the Console. You should see what
packages were loaded (ggplot2, tibble, etc.) and conflicts. 

You should also see 2 conflicts:

-   x dplyr::filter() masks stats::filter()
-   x dplyr::lag() masks stats::lag()

Those are okay! You can read that as: The filter command in the dplyr
package masks the filter command in the stats package.

If you see a Warning Message in red text below the conflicts, that is an
error you need to fix.

## What is an Environment?

Your environment includes your objects saved into memory and any loaded 
librarys.RStudio Projects give you a fresh "environment." That basically clears 
your workspace by removing any objects, and also clears any libraries that you 
may have loaded previously.

It's a good practice to start, and frequently re-start, with a fresh
environment.

# Import homes data - Our First Data Frame

We will use real data about homes in Albemarle County. 

## Relative Paths

We need to point R to where the dataset is stored. Recall what we said
about setting the working directory with hard-coded paths: they break
too easily and are just annoying when they do.

A hard-coded path pointing to our dataset in Windows could look like
this:
`C:/Users/jah2ax.ESERVICES/Box Sync/_R/workshops/intro_R/data-raw/albemarle_homes_2022.csv`

On a Mac it could look like this:
`~/Users/jah2ax.ESERVICES/Box Sync/_R/workshops/intro_R/data-raw/albemarle_homes_2022.csv`

Instead of using a hard-coded path, we will use a *relative* path. That
means that we start from the working directory and move around from
there.

```{r}
#read in data
homes <- read_csv('data-raw/albemarle_homes_2022.csv') 
```

## Evaluate Data, Part 1

Get an overall view:

```{r}
homes        # print to console
View(homes)  # view spreadsheet-style data viewer
            # You can also click on "homes" in your Environment pane
```

Size:

```{r}
nrow(homes)  # number of rows
ncol(homes)  # number of columns
dim(homes)   # number of rows and number of columns (the DIMensions of the object)
```

Content (print out a few rows, either first or last rows):
Type: head...open parenthesis...homes
Type: tail...open parenthesis...homes
```{r}

 
```

Column (aka variable) names:
Type: names...open parenthesis...homes
```{r}

```

Summaries:

`summary()`: Get a quick statistical summary of the dataset. Notice that
some variables get a frequency count while others get a six number
summary (e.g., mean, median).

Type: summary...open parenthesis...homes
```{r}

```

`str()`: View structure of the homes data. You can also view the
structure by clicking on the little blue arrow next to the object in
your Environment.

Type: str...open parenthesis...homes
```{r}

```

`glimpse()`: Returns the number of columns and rows of the tibble, the
names and class of each column, and previews as many values will fit on
the screen. glimpse() is from the dplyr or tibble package, while
everything else in this section is from base R.

Type: glimpse...open parenthesis...homes
```{r}

```

## Factors: categorical data

Notice in our summary() and str() print outs, we see a lot of data that
looks numeric, but is not really numeric. It's categorical. Let's focus
on `sex`. Here, we have two categories: males and female. Males are
coded as 1 and females are coded as 2. The output says that the mean is
1.384, but really, it doesn't make any sense to have a mean of sex. We
should convert those numeric variables into categorical ones.

In R, categorical data are called factors. Factors are a class of data,
just like numeric or character data.

Here is a quick (lazy!) way of importing all character (string) data as factors:

```{r}

# set up factors ---------------------------------------------------------------
homes_factors <- read.csv("data-raw/albemarle_homes_2022.csv", stringsAsFactors = TRUE)
str(homes_factors)
```

Compare str(homes) and str(homes_factor).  The character data in 'homes' are now Factors with Levels. Looking at 'hsdistrict' again, it shows "Factor w/ 4 levels". Also notice the numbers that follow. Factors are stored in memory as integers, and the integers have associated "labels". 

Investigate factors for high school district:

```{r}
levels(homes_factors$hsdistrict)
```

Check out tidyverse's forcats package for more details on how to manage factors.

## Evaluate Data, Part 2

**Use \$ to reference elements in a data frame (aka indexing):**

Below summary, type: mean...open parentheses...homes...dollar sign...lotsize
```{r}
summary(homes$lotsize)  # Summary of lotsize variable
```

**Use logical vectors to query data:**

Note: 
- TRUE is stored as 1 
- FALSE is stored as 0

```{r}
# number of homes over $1,000,000
sum(homes$totalvalue > 1e6) # 1e6 is fast way of writing 1,000,000
                            # (i.e., 1 followed by 6 zeros) in R

```

For each observation, if the total value is over $1,000,000, R considers that TRUE, which is stored as a 1.  Then R sums up all those 1's with the sum() function.) 

```{r}
# proportion of homes over $1,000,000 (mean of 0s and 1s as a proportion of 1s)
mean(homes$totalvalue > 1e6)
```

**Use `tables()` to create tables:**

```{r}
# count of homes by hs district
table(homes$hsdistrict)
```

```{r}
# count of homes by cooling (central air) status
table(homes$cooling)
```

```{r}
# table of homes in hsdistrict by cooling status
# the first argument fills in the rows, the second fills in the columns
table(homes$hsdistrict, homes$cooling)
```

## Beware of missing data

Missing data is represented by NA.

```{r}
sum(is.na(homes$bedroom)) # there is 1 observation with missing bedroom data.
```

Many functions will return NA if the data include missing values.

```{r}
mean(homes$bedroom)
```

You can add the argument `na.rm = TRUE` to ignore missing values.

```{r}
mean(homes$bedroom, na.rm = TRUE)
```

## Your Turn \#3

1.  Print the last 8 lines of `homes`

2.  Use the function median() to calculate the median of the number of full baths (fullbath) in 'homes'

3. Create a table that includes middle school district (msdistrict) as rows, 
and condition as columns.

4.  Fix these commands so they run correctly:

```{r}
median(homes$Bedrooms, na.rm = TRUE)
Mean(homes$landvalue)
```

# Filling out our Project Directory

This part is not specific to R or RStudio.

Using a consistent folder structure across your projects will help keep
things organized and make it easy to find your files in the future.

**Create a chart**

Let's create a quick chart.

```{r}
# bar chart of homes total value 
ggplot(homes, aes(x = totalvalue)) +  
  geom_histogram()                     

# don't worry about this code!
# save your questions for the data viz workshop!
```

In the Files pane (lower right), verify that the folder displays your
working directory...click on "New Folder"...create a new folder
called...output. (The new folder might not be visible in the Files pane
right away.)

```{r}
# save figure 
ggsave("output/total_value.png")
```

**Save our data**

Let's save our data now.

(I admit, this isn't a perfect example, since we didn't really make any changes
to the raw dataset.  We might as well use our homes_factors since we took the 
time to convert the strings to factors.)

In the Files pane (lower right), verify that the folder displays your
working directory...click on "New Folder"...create a new folder
called...data-processed. (The new folder might not be visible in the
Files pane right away.)

```{r}
# Save your homes_factors object as an Rds file.
saveRDS(homes_factors, file = "data-processed/homes_factors.Rds")
```

## Keeping R up to date

Since most people in our workshop have freshly installed R and RStudio,
we hopefully didn't encounter any issues with old versions today. But
eventually, you will have to update R.

Remember that at the top of the Console, you will see session info, e.g.
R version 4.1.1 (2021-08-10) -- "Kick Things"

This tells us what version of R that RStudio is using.

You can also check the version with the version command:

```{r version}
version
```

After you load packages, sometimes you will see a Warning Message in red
text below the any conflicts:

`Warning message: package 'tidyverse' was built under R version [x.y.z]`

If you see a message like that, it is time to update R. Updating R means
that you have to download and install R again. By default, your computer
will keep your old version of R, and you can decide if you want to
delete it or not. RStudio will automatically recognize the new version
of R. When you install a new version of R, you have to re-install your
packages. Windows users can try the [installr
package](https://www.r-statistics.com/2015/06/a-step-by-step-screenshots-tutorial-for-upgrading-r-on-windows/).

It is a good idea to occasionally check for package updates (e.g.,
tidyverse): Tools...Check for Package Updates.

It is a good idea to occasionally check for RStudio updates:
Help...Check for Updates.

# Assessment
Assessment: https://virginia.libwizard.com/f/data-literacy
